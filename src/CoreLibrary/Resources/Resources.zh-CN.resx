<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AppTerminated" xml:space="preserve">
    <value>已终止应用: {0}</value>
  </data>
  <data name="AttemptingContainerTaskRun" xml:space="preserve">
    <value>正在尝试在容器中运行任务...</value>
  </data>
  <data name="AttemptingFileLoad" xml:space="preserve">
    <value>已找到 {0} , 正在尝试加载...</value>
  </data>
  <data name="AUMIDNotValidError" xml:space="preserve">
    <value>AUMID 无效!</value>
  </data>
  <data name="BackgroundRetryException" xml:space="preserve">
    <value>BackgroundTask 不能有重试值!</value>
  </data>
  <data name="BackgroundTaskTypeException" xml:space="preserve">
    <value>BackgroundTask 必须是 ExecutableTask、PowerShellTask 或 BatchFileTask!</value>
  </data>
  <data name="BackgroundTimeoutException" xml:space="preserve">
    <value>BackgroundTask 不能有超时值!</value>
  </data>
  <data name="BootTasksExecutingError" xml:space="preserve">
    <value>服务启动任务仍在执行! 等待它们完成或调用 AbortAll()。</value>
  </data>
  <data name="BootTasksFinished" xml:space="preserve">
    <value>Factory Orchestrator 服务已完成启动任务执行。</value>
  </data>
  <data name="BootTasksStarted" xml:space="preserve">
    <value>Factory Orchestrator 服务正在执行启动任务...</value>
  </data>
  <data name="CheckingForFile" xml:space="preserve">
    <value>正在检查 {0}...</value>
  </data>
  <data name="ClientNotConnected" xml:space="preserve">
    <value>先启动连接!</value>
  </data>
  <data name="ContainerFileGetFailed" xml:space="preserve">
    <value>无法从容器中获取文件!</value>
  </data>
  <data name="ContainerFileSendFailed" xml:space="preserve">
    <value>无法将文件发送到容器!</value>
  </data>
  <data name="ContainerTaskRunFailed" xml:space="preserve">
    <value>无法在容器中完成 TaskRun</value>
  </data>
  <data name="DoneWaitingForExternalTaskRun" xml:space="preserve">
    <value>外部 TaskRun {0} 收到 {1} 结果并且已完成。</value>
  </data>
  <data name="DuplicateTaskRunGuid" xml:space="preserve">
    <value>无法从文件加载 TaskRun {0}，因为它已存在！</value>
  </data>
  <data name="EndContainerOutput" xml:space="preserve">
    <value>结束容器进程输出</value>
  </data>
  <data name="EndWaitingForExternalResult" xml:space="preserve">
    <value>FactoryOrchestratorClient 已完成 TaskRun，状态为: {0}，退出代码为: {1}</value>
  </data>
  <data name="FactoryOrchestratorConnectionException" xml:space="preserve">
    <value>无法与 {0} 上的 Factory Orchestrator 服务通信</value>
  </data>
  <data name="FactoryOrchestratorTaskListRunningException" xml:space="preserve">
    <value>无法执行操作，因为一个或多个 TaskLists 正在运行！</value>
  </data>
  <data name="FactoryOrchestratorTaskListRunningExceptionWithGuid" xml:space="preserve">
    <value>无法执行操作，因为 TaskList {0} 当前正在运行！</value>
  </data>
  <data name="FactoryOrchestratorUnkownGuidException" xml:space="preserve">
    <value>Guid 无效!</value>
  </data>
  <data name="FactoryOrchestratorUnkownGuidExceptionWithGuid" xml:space="preserve">
    <value>{0} 无效!</value>
  </data>
  <data name="FactoryOrchestratorUnkownGuidExceptionWithGuidAndType" xml:space="preserve">
    <value>{0} 不是有效的 {1}!</value>
  </data>
  <data name="FactoryOrchestratorVersionMismatchException" xml:space="preserve">
    <value>{0} 上的 Factory Orchestrator 服务版本为 {1}，与 FactoryOrchestratorClient 版本 {2} 不兼容! 连接时使用 Connect(true) 或 TryConnect(true) 忽略此错误。</value>
  </data>
  <data name="FileLoadSucceeded" xml:space="preserve">
    <value>已成功加载 {0}。</value>
  </data>
  <data name="FileNotFound" xml:space="preserve">
    <value>未找到 {0}。</value>
  </data>
  <data name="FileNotFoundException" xml:space="preserve">
    <value>{0} 不存在!</value>
  </data>
  <data name="FileSaveError" xml:space="preserve">
    <value>无法保存目标文件 {0}!</value>
  </data>
  <data name="Finish" xml:space="preserve">
    <value>完成</value>
  </data>
  <data name="FOXMLFileLoadException" xml:space="preserve">
    <value>无法加载 {0} 作为 FactoryOrchestratorXML!</value>
  </data>
  <data name="InvalidPathError" xml:space="preserve">
    <value>{0} 不是有效的文件或文件夹！</value>
  </data>
  <data name="InvalidTaskRunTypeException" xml:space="preserve">
    <value>TaskRun 的 TaskType 无效!</value>
  </data>
  <data name="LogFileCreationFailed" xml:space="preserve">
    <value>警告：无法创建日志文件 {0}</value>
  </data>
  <data name="LogFolderMoveFailed" xml:space="preserve">
    <value>无法移动日志文件夹!</value>
  </data>
  <data name="NetworkAccessDisabled" xml:space="preserve">
    <value>已禁用 Factory Orchestrator 服务网络访问权限。</value>
  </data>
  <data name="NetworkAccessEnabled" xml:space="preserve">
    <value>已启用 Factory Orchestrator 服务网络访问权限。</value>
  </data>
  <data name="NoContainerIdFound" xml:space="preserve">
    <value>找不到有效的容器 ID!</value>
  </data>
  <data name="NoContainerIpFound" xml:space="preserve">
    <value>找不到有效的容器 IP 地址!</value>
  </data>
  <data name="NoMethodFound" xml:space="preserve">
    <value>找不到名为 {0} 的方法</value>
  </data>
  <data name="NoTaskListsException" xml:space="preserve">
    <value>没有要保存的 TaskList!</value>
  </data>
  <data name="ProcessExited" xml:space="preserve">
    <value>已退出进程。</value>
  </data>
  <data name="ProcessStartError" xml:space="preserve">
    <value>流程未能启动!</value>
  </data>
  <data name="ReadyToCommunicate" xml:space="preserve">
    <value>Factory Orchestrator 服务已准备好与客户端通信。</value>
  </data>
  <data name="RedirectingToRunAsRDUser" xml:space="preserve">
    <value>{0} 是一个 Win32 GUI 程序。正在重定向以远程用户身份运行...</value>
    <comment>Message shown when program the user wants to run is detected to be a GUI program, which need to run as a user account, not SYSTEM.</comment>
  </data>
  <data name="RedirectingUWPToRunAs" xml:space="preserve">
    <value>{0} 是一个要在容器中运行的 UWP 应用程序。正在重定向以远程用户身份在容器中运行...</value>
    <comment>Message shown when program the user wants to run in the container is a UWP app, which need to run as a user account, not SYSTEM.</comment>
  </data>
  <data name="RunningGuiAsSystemWarning" xml:space="preserve">
    <value>警告： {0} 是 Win32 GUI 程序。它可能无法作为系统正常运行。</value>
    <comment>Message shown when program the user wants to run is detected to be a GUI program, but the code to run as a user account is not present on the device.</comment>
  </data>
  <data name="ServiceAlreadyCreatedError" xml:space="preserve">
    <value>已创建 FactoryOrchestratorService! 仅允许一个实例。</value>
  </data>
  <data name="ServiceErrored" xml:space="preserve">
    <value>服务 {0} 出错，出现异常</value>
  </data>
  <data name="ServiceStarted" xml:space="preserve">
    <value>已启动 {0} 服务</value>
  </data>
  <data name="ServiceStarting" xml:space="preserve">
    <value>服务 {0} 正在启动</value>
  </data>
  <data name="ServiceStopped" xml:space="preserve">
    <value>服务 {0} 已停止</value>
  </data>
  <data name="ServiceStoppedWithName" xml:space="preserve">
    <value>已停止 Factory Orchestrator 服务。</value>
  </data>
  <data name="ServiceStopping" xml:space="preserve">
    <value>正在停止服务 {0}</value>
  </data>
  <data name="ServiceStopSaveError" xml:space="preserve">
    <value>无法在服务停止时保存 TaskList!</value>
  </data>
  <data name="SourceDirectoryNotFound" xml:space="preserve">
    <value>源目录不存在或无法找到:</value>
  </data>
  <data name="Start" xml:space="preserve">
    <value>开始</value>
  </data>
  <data name="StartContainerOutput" xml:space="preserve">
    <value>启动容器进程输出</value>
  </data>
  <data name="MoveContainerPathFailed" xml:space="preserve">
    <value>无法将文件或文件夹 {0} 移动到容器中 {1}！</value>
  </data>
  <data name="DeleteContainerPathFailed" xml:space="preserve">
    <value>无法删除容器中 {0} 的文件或文件夹！</value>
  </data>
  <data name="OpenNonMutableKeyFailed" xml:space="preserve">
    <value>无法打开 NonMutable 注册表项!</value>
  </data>
  <data name="OpenVolatileKeyFailed" xml:space="preserve">
    <value>无法打开 Volatile 注册表项!</value>
  </data>
  <data name="CreateDirectoryFailed" xml:space="preserve">
    <value>无法创建 {0} 目录!</value>
  </data>
  <data name="TaefCheckFailed" xml:space="preserve">
    <value>无法调用 TE.exe 以验证可能的 TAEF 测试： {0}</value>
  </data>
  <data name="TaefCheckReturnedError" xml:space="preserve">
    <value>尝试验证可能的 TAEF 测试时返回错误 {0} TE.exe： {1}</value>
  </data>
  <data name="TaefCheckTimeout" xml:space="preserve">
    <value>尝试验证可能的 TAEF 测试时超时 TE.exe： {0}</value>
  </data>
  <data name="TaefValidationFailed" xml:space="preserve">
    <value>无法验证可能的 TAEF 测试: {0}</value>
  </data>
  <data name="TaskBaseDeserializationException" xml:space="preserve">
    <value>正在尝试反序列化未知任务类型!</value>
  </data>
  <data name="TaskBaseSerializationException" xml:space="preserve">
    <value>正在尝试序列化未知任务类型!</value>
  </data>
  <data name="TaskListCountMismatch" xml:space="preserve">
    <value>服务器已 {0} TaskLists 但是新订单只具有 {1} Guid！</value>
  </data>
  <data name="TaskListExistsAlready" xml:space="preserve">
    <value>已存在 guid 为 {0} 的 TaskList!</value>
  </data>
  <data name="TaskListSaveFailed" xml:space="preserve">
    <value>无法将 TaskLists 保存到 {0}!</value>
  </data>
  <data name="TaskListToString" xml:space="preserve">
    <value>TaskList {0} ({1})，状态为 {2}</value>
  </data>
  <data name="TooManyMethodsFound" xml:space="preserve">
    <value>有多个名称为 {0} 的方法</value>
  </data>
  <data name="UnsupportedGuidType" xml:space="preserve">
    <value>要轮询的不受支持的 guid 类型!</value>
  </data>
  <data name="WaitingForContainerTaskRun" xml:space="preserve">
    <value>TaskRun {0} 正在等待容器运行的结果。</value>
  </data>
  <data name="WaitingForExternalTaskRun" xml:space="preserve">
    <value>TaskRun {0} 正在等待外部结果。</value>
  </data>
  <data name="WDPAppLaunchFailed" xml:space="preserve">
    <value>错误: 未能启动 AUMID: {0}</value>
  </data>
  <data name="WDPAppLaunchFailed2" xml:space="preserve">
    <value>错误: 需要设备门户才能启动应用，并且可能不在系统上运行。</value>
  </data>
  <data name="WDPAppLaunchFailed3" xml:space="preserve">
    <value>错误：如果它正在运行，AUMID 可能不正确。</value>
  </data>
  <data name="WDPAppLaunchSucceeded" xml:space="preserve">
    <value>已成功启动应用，且 AUMID: {0}</value>
  </data>
  <data name="WDPError" xml:space="preserve">
    <value>Windows 设备门户失败，出现错误</value>
  </data>
  <data name="WDPHttpError" xml:space="preserve">
    <value>Windows 设备门户失败，出现 HTTP 错误</value>
  </data>
  <data name="WDPNotRunningError" xml:space="preserve">
    <value>必须运行 Windows 设备门户才能调用 GetInstalledApps！</value>
  </data>
  <data name="WindowsOnlyError" xml:space="preserve">
    <value>{0} 仅在 Windows 上受支持!</value>
  </data>
  <data name="EnablingLoopback" xml:space="preserve">
    <value>正在为 {0}启用 UWP 本地环回...</value>
  </data>
  <data name="EnablingLoopbackFailed" xml:space="preserve">
    <value>无法为 {0} 启用 UWP 本地环回! 你可能无法从 {0} 与 Factory Orchestrator 服务通信。</value>
  </data>
  <data name="EveryBootAlreadyComplete" xml:space="preserve">
    <value>首次启动 TaskList 已完成。</value>
  </data>
  <data name="EveryBootComplete" xml:space="preserve">
    <value>每次启动 TaskList 完成。</value>
  </data>
  <data name="EveryBootFailed" xml:space="preserve">
    <value>无法完成每次启动 TaskList!</value>
  </data>
  <data name="EveryBootRunningTaskList" xml:space="preserve">
    <value>正在运行每次启动 TaskList {0}...</value>
  </data>
  <data name="EveryBootWaiting" xml:space="preserve">
    <value>等待每次启动 TaskList 完成...(如果你不希望它们退出，请将其标记为 BackgroundTask。)</value>
  </data>
  <data name="FirstBootAlreadyComplete" xml:space="preserve">
    <value>首次启动 TaskList 已完成!</value>
  </data>
  <data name="FirstBootComplete" xml:space="preserve">
    <value>首次启动 TaskList 完成。</value>
  </data>
  <data name="FirstBootFailed" xml:space="preserve">
    <value>无法完成首次启动 TaskList!</value>
  </data>
  <data name="FirstBootRunningTaskList" xml:space="preserve">
    <value>正在运行每次启动 TaskList {0}...</value>
  </data>
  <data name="FirstBootWaiting" xml:space="preserve">
    <value>等待首次启动 TaskList 完成...(如果你不希望测试退出，请将它们标记为 BackgroundTask。)</value>
  </data>
  <data name="ServiceProcessExitedWithError" xml:space="preserve">
    <value>{0} 已退出，出现 {1}!</value>
  </data>
  <data name="ServiceProcessStartFailed" xml:space="preserve">
    <value>{0} 从未启动!</value>
  </data>
  <data name="ServiceProcessTimedOut" xml:space="preserve">
    <value>{0} 未在 {1}ms 前退出!</value>
  </data>
  <data name="DuplicateGuidInXml" xml:space="preserve">
    <value>FactoryOrchestratorXML 中的 Duplicate Guid {0}!</value>
  </data>
  <data name="ContainerConnected" xml:space="preserve">
    <value>Factory Orchestrator 服务已连接到运行兼容版本的 Factory Orchestrator 服务的容器。</value>
    <comment>container refers to a Windows container running on the host device (eg https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/)</comment>
  </data>
  <data name="ContainerDisconnected" xml:space="preserve">
    <value>Factory Orchestrator 服务已与运行兼容版本的 Factory Orchestrator 服务的容器断开连接。</value>
    <comment>container refers to a Windows container running on the host device (eg https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/)</comment>
  </data>
  <data name="IpcInvalidOperationError" xml:space="preserve">
    <value>Factory Orchestrator 服务未识别该命令! 最大的原因是客户端和服务之间版本不匹配。</value>
    <comment>Error when service does not recognize a command from client. Almost always due to using an older client with a newer service.</comment>
  </data>
  <data name="Unknown" xml:space="preserve">
    <value>未知</value>
  </data>
  <data name="ContainerConnectionFailed" xml:space="preserve">
    <value>无法连接到容器内部的 Factory Orchestrator 服务！</value>
    <comment>Error thrown if we cannot connect to the service inside the container for any reason</comment>
  </data>
  <data name="TaskRunUnhandledExceptionError" xml:space="preserve">
    <value>错误：TaskRun 在执行期间引发了未处理的异常！</value>
    <comment>Error message shown when TaskRun encounters an unhandled exception while running.</comment>
  </data>
  <data name="WaitingForContainerStart" xml:space="preserve">
    <value>正在等待容器准备就绪…</value>
    <comment>Message shown when the container inside the host is not yet ready to execute the desired Task.</comment>
  </data>
  <data name="ContainerTaskTypeException" xml:space="preserve">
    <value>容器中运行的任务的类型必须为 ExecutableTask、BatchFileTask 或 PowerShellTask！</value>
    <comment>Exception message when a Task the user wants run in the container is of an invalid type</comment>
  </data>
</root>