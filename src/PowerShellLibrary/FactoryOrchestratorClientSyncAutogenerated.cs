// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
//
// Autogenerated by building FactoryOrchestratorCoreLibrary. DO NOT MODIFY, CHANGES WILL BE LOST.
//

using Microsoft.FactoryOrchestrator.Core;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using TaskStatus = Microsoft.FactoryOrchestrator.Core.TaskStatus;

namespace Microsoft.FactoryOrchestrator.Client
{
    public partial class FactoryOrchestratorClientSync
    {
        /// <summary>
        /// Stops all running Tasks and deletes all TaskLists.
        /// </summary>
        /// <param name="preserveLogs">If true, are logs not deleted.</param>
        /// <param name="factoryReset">If true, the service is restarted as if it is first boot.</param>
        public void ResetService(bool preserveLogs = false, bool factoryReset = false)
        {
            AsyncClient.ResetService(preserveLogs , factoryReset ).Wait();
        }

        /// <summary>
        /// Gets all Service events.
        /// </summary>
        /// <returns>List of all Service events.</returns>
        public List<ServiceEvent> GetServiceEvents()
        {
            return AsyncClient.GetServiceEvents().Result;
        }

        /// <summary>
        /// Get all Service events since given time.
        /// </summary>
        /// <param name="timeLastChecked"></param>
        /// <returns>List of Service events.</returns>
        public List<ServiceEvent> GetServiceEvents(DateTime timeLastChecked)
        {
            return AsyncClient.GetServiceEvents(timeLastChecked).Result;
        }

        /// <summary>
        /// Get all Service events since given index.
        /// </summary>
        /// <param name="lastEventIndex"></param>
        /// <returns>List of Service events.</returns>
        public List<ServiceEvent> GetServiceEvents(ulong lastEventIndex)
        {
            return AsyncClient.GetServiceEvents(lastEventIndex).Result;
        }

        /// <summary>
        /// Get last Service error.
        /// </summary>
        /// <returns></returns>
        public ServiceEvent GetLastServiceError()
        {
            return AsyncClient.GetLastServiceError().Result;
        }

        /// <summary>
        /// Returns the version of Factory Orchestrator Service.
        /// </summary>
        /// <returns>string representing the Service version.</returns>
        public string GetServiceVersionString()
        {
            return AsyncClient.GetServiceVersionString().Result;
        }

        /// <summary>
        /// Returns the version of the Windows OS.
        /// </summary>
        /// <returns>string representing the Windows OS version.</returns>
        public string GetOSVersionString()
        {
            return AsyncClient.GetOSVersionString().Result;
        }

        /// <summary>
        /// Returns the version set by the OEM duing WSK Image Customization.
        /// </summary>
        /// <returns>string representing the OEM version.</returns>
        public string GetOEMVersionString()
        {
            return AsyncClient.GetOEMVersionString().Result;
        }

        /// <summary>
        /// Sets the path to TE.exe, used to run TAEF tests.
        /// </summary>
        /// <param name="teExePath">Path to TE.exe</param>
        /// <returns></returns>
        public void SetTeExePath(string teExePath)
        {
            AsyncClient.SetTeExePath(teExePath).Wait();
        }

        /// <summary>
        /// Sets the log folder path used by Factory Orchestrator.
        /// </summary>
        /// <param name="path">Path to the desired folder.</param>
        /// <param name="moveExistingLogs">If true, existing logs are moved to the new location.</param>
        /// <returns></returns>
        public void SetLogFolder(string path, bool moveExistingLogs)
        {
            AsyncClient.SetLogFolder(path, moveExistingLogs).Wait();
        }

        /// <summary>
        /// Gets the log folder path used by Factory Orchestrator.
        /// </summary>
        /// <returns>Path to the log folder.</returns>
        public string GetLogFolder()
        {
            return AsyncClient.GetLogFolder().Result;
        }

        /// <summary>
        /// Gets a list of IP addresses and the Network Adapter each IP address belongs to.
        /// </summary>
        /// <returns>A list of IP addresses and the Network Adapter each IP address belongs to.</returns>
        public List<Tuple<string, string>> GetIpAddressesAndNicNames()
        {
            return AsyncClient.GetIpAddressesAndNicNames().Result;
        }

        /// <summary>
        /// Gets a list of IP addresses for the container. These IPs are internal, they cannot be accessed outside of the host.
        /// </summary>
        /// <returns>A list of IP addresses for the container.</returns>
        public List<string> GetContainerIpAddresses()
        {
            return AsyncClient.GetContainerIpAddresses().Result;
        }

        /// <summary>
        /// Checks if the service is executing boot tasks. While executing boot tasks, many commands cannot be run.
        /// </summary>
        /// <returns><c>true</c> is the service is executing boot tasks.</returns>
        public bool IsExecutingBootTasks()
        {
            return AsyncClient.IsExecutingBootTasks().Result;
        }

        /// <summary>
        /// Determines whether the connected device has a container present and running.
        /// </summary>
        /// <returns>
        ///   <c>true</c> if container is present and running; otherwise, <c>false</c>.
        /// </returns>
        public bool IsContainerRunning()
        {
            return AsyncClient.IsContainerRunning().Result;
        }

        /// <summary>
        /// Gets a list of Factory Orchestrator App pages that were disabled by OEM Customization.
        /// </summary>
        /// <returns>A list of page tags that should be disabled.</returns>
        public List<string> GetDisabledPages()
        {
            return AsyncClient.GetDisabledPages().Result;
        }

        /// <summary>
        /// Checks if the service supports network access.
        /// </summary>
        /// <returns><c>true</c> if the service allows connections over the local network.</returns>
        public bool IsNetworkAccessEnabled()
        {
            return AsyncClient.IsNetworkAccessEnabled().Result;
        }

        /// <summary>
        /// Creates a new TaskList by finding all .exe, .cmd, .bat, .ps1, and TAEF files in a given folder.
        /// </summary>
        /// <param name="path">Path of the directory to search.</param>
        /// <param name="recursive">If true, search recursively.</param>
        /// <returns>The created TaskList</returns>
        public TaskList CreateTaskListFromDirectory(string path, bool recursive = false)
        {
            return AsyncClient.CreateTaskListFromDirectory(path, recursive ).Result;
        }

        /// <summary>
        /// Creates new TaskLists by loading them from a FactoryOrchestratorXML file.
        /// </summary>
        /// <param name="filename">The path to the FactoryOrchestratorXML file.</param>
        /// <returns>The GUID(s) of the created TaskList(s)</returns>
        public List<Guid> LoadTaskListsFromXmlFile(string filename)
        {
            return AsyncClient.LoadTaskListsFromXmlFile(filename).Result;
        }

        /// <summary>
        /// Saves a TaskList to a FactoryOrchestratorXML file.
        /// </summary>
        /// <param name="guid">The GUID of the TaskList you wish to save.</param>
        /// <param name="filename">The path to the FactoryOrchestratorXML file that will be created.</param>
        /// <returns>true on success</returns>
        public void SaveTaskListToXmlFile(Guid guid, string filename)
        {
            AsyncClient.SaveTaskListToXmlFile(guid, filename).Wait();
        }

        /// <summary>
        /// Saves all TaskLists in the Service to a FactoryOrchestratorXML file.
        /// </summary>
        /// <param name="filename">The path to the FactoryOrchestratorXML file that will be created.</param>
        /// <returns>true on success</returns>
        public void SaveAllTaskListsToXmlFile(string filename)
        {
            AsyncClient.SaveAllTaskListsToXmlFile(filename).Wait();
        }

        /// <summary>
        /// Creates a TaskList on the Service by copying a TaskList object provided by the Client.
        /// </summary>
        /// <param name="list">The TaskList to add to the Service.</param>
        /// <returns>The created Service TaskList.</returns>
        public TaskList CreateTaskListFromTaskList(TaskList list)
        {
            return AsyncClient.CreateTaskListFromTaskList(list).Result;
        }

        /// <summary>
        /// Gets the GUID of every "active" TaskList on the Service. If "IsExecutingBootTasks()" returns true, this returns the "boot" TaskLists. Otherwise, it returns the "normal" TaskLists.
        /// </summary>
        /// <returns>The list of TaskList GUIDs.</returns>
        public List<Guid> GetTaskListGuids()
        {
            return AsyncClient.GetTaskListGuids().Result;
        }

        /// <summary>
        /// Gets TaskList summaries for every "active" TaskList on the Service.  If "IsExecutingBootTasks()" returns true, this returns the "boot" TaskLists. Otherwise, it returns the "normal" TaskLists. The summary contains basic info about the TaskList.
        /// </summary>
        /// <returns>A list of TaskListSummary objects.</returns>
        public List<TaskListSummary> GetTaskListSummaries()
        {
            return AsyncClient.GetTaskListSummaries().Result;
        }

        /// <summary>
        /// Gets the GUID of every "boot" TaskList on the Service.
        /// </summary>
        /// <returns>The list of TaskList GUIDs.</returns>
        public List<Guid> GetBootTaskListGuids()
        {
            return AsyncClient.GetBootTaskListGuids().Result;
        }

        /// <summary>
        /// Gets "boot" TaskList summaries for every "boot" TaskList on the Service. The summary contains basic info about the TaskList.
        /// </summary>
        /// <returns>A list of TaskListSummary objects.</returns>
        public List<TaskListSummary> GetBootTaskListSummaries()
        {
            return AsyncClient.GetBootTaskListSummaries().Result;
        }

        /// <summary>
        /// Gets the TaskList object for a given TaskList GUID.
        /// </summary>
        /// <param name="taskListGuid">The TaskList GUID.</param>
        /// <returns>The TaskList object with that GUID.</returns>
        public TaskList QueryTaskList(Guid taskListGuid)
        {
            return AsyncClient.QueryTaskList(taskListGuid).Result;
        }

        /// <summary>
        /// Deletes a TaskList on the Service.
        /// </summary>
        /// <param name="listToDelete">The GUID of the TaskList to delete.</param>
        /// <returns>true if it was deleted successfully.</returns>
        public void DeleteTaskList(Guid listToDelete)
        {
            AsyncClient.DeleteTaskList(listToDelete).Wait();
        }

        /// <summary>
        /// Updates an existing TaskList on the Service.
        /// </summary>
        /// <param name="taskList">The updated TaskList.</param>
        /// <returns>true if it was updated successfully.</returns>
        public void UpdateTaskList(TaskList taskList)
        {
            AsyncClient.UpdateTaskList(taskList).Wait();
        }

        /// <summary>
        /// Reorders the TaskLists known to the Service.
        /// </summary>
        /// <param name="newOrder">An ordered list of GUIDs corresponding to the TaskList GUIDs known to the Service.</param>
        public void ReorderTaskLists(List<Guid> newOrder)
        {
            AsyncClient.ReorderTaskLists(newOrder).Wait();
        }

        /// <summary>
        /// Returns the Task object for a given Task GUID.
        /// </summary>
        /// <param name="guid">The Task GUID.</param>
        /// <returns></returns>
        public TaskBase QueryTask(Guid guid)
        {
            return AsyncClient.QueryTask(guid).Result;
        }

        /// <summary>
        /// Gets the AUMIDs of all installed apps on the OS. Requires Windows Device Portal.
        /// </summary>
        /// <returns>The list of app AUMIDs.</returns>
        public List<string> GetInstalledApps()
        {
            return AsyncClient.GetInstalledApps().Result;
        }

        /// <summary>
        /// Installs an app package on the Service's computer. The app package must already be on the Service's computer. Requires Windows Device Portal.
        /// If the app package is not on the Service's computer already, use SendAndInstallApp() to copy and install it instead.
        /// </summary>
        /// <param name="appPackagePath">Path on the Service's computer to the app package (.appx, .appxbundle, .msix, .msixbundle).</param>
        /// <param name="dependentPackages">List of paths on the Service's computer to the app's dependent packages.</param>
        /// <param name="certificateFile">Path on the Service's computer to the app's certificate file, if needed. Microsoft Store signed apps do not need a certificate.</param>
        public void InstallApp(string appPackagePath, List<string> dependentPackages = null, string certificateFile = null)
        {
            AsyncClient.InstallApp(appPackagePath, dependentPackages , certificateFile ).Wait();
        }

        /// <summary>
        /// Enables local loopback on the given UWP app.
        /// </summary>
        /// <param name="aumid">The Application User Model ID (AUMID) of the app to enable local loopback on.</param>
        public void EnableLocalLoopbackForApp(string aumid)
        {
            AsyncClient.EnableLocalLoopbackForApp(aumid).Wait();
        }

        /// <summary>
        /// Executes all TaskLists in order.
        /// </summary>
        /// <returns><c>true</c> if the TaskLists are successfully queued to run.</returns>
        public bool RunAllTaskLists()
        {
            return AsyncClient.RunAllTaskLists().Result;
        }

        /// <summary>
        /// Executes a TaskList.
        /// </summary>
        /// <param name="taskListGuid">GUID of the TaskList to run.</param>
        /// <param name="initialTask">Index of the Task to start the run from.</param>
        /// <returns></returns>
        public void RunTaskList(Guid taskListGuid, int initialTask = 0)
        {
            AsyncClient.RunTaskList(taskListGuid, initialTask ).Wait();
        }

        /// <summary>
        /// Stops all executing Tasks and/or TaskLists.
        /// </summary>
        public void AbortAll()
        {
            AsyncClient.AbortAll().Wait();
        }

        /// <summary>
        /// Stops executing a TaskList.
        /// </summary>
        /// <param name="taskListGuid">The GUID of the TaskList to stop.</param>
        public void AbortTaskList(Guid taskListGuid)
        {
            AsyncClient.AbortTaskList(taskListGuid).Wait();
        }

        /// <summary>
        /// Stops executing a TaskRun.
        /// </summary>
        /// <param name="taskRunGuid">The GUID of the TaskRun to stop.</param>
        public void AbortTaskRun(Guid taskRunGuid)
        {
            AsyncClient.AbortTaskRun(taskRunGuid).Wait();
        }

        /// <summary>
        /// Runs an executable (.exe) outside of a Task/TaskList.
        /// </summary>
        /// <param name="exeFilePath">Full path to the .exe file</param>
        /// <param name="arguments">Arguments to pass to the .exe</param>
        /// <param name="logFilePath">Optional log file to save the console output to.</param>
        /// <param name="runInContainer">If true, run the executable in the container of the connected device.</param>
        /// <returns>The TaskRun associated with the .exe</returns>
        public TaskRun RunExecutable(string exeFilePath, string arguments, string logFilePath = null, bool runInContainer = false)
        {
            return AsyncClient.RunExecutable(exeFilePath, arguments, logFilePath , runInContainer ).Result;
        }

        /// <summary>
        /// Runs a UWP app outside of a Task/TaskList. Requires Windows Device Portal.
        /// </summary>
        /// <param name="aumid">The Application User Model ID (AUMID) of the app to run.</param>
        /// <returns></returns>
        public TaskRun RunApp(string aumid)
        {
            return AsyncClient.RunApp(aumid).Result;
        }

        /// <summary>
        /// Runs a Task outside of a TaskList.
        /// </summary>
        /// <param name="taskGuid">The GUID of the Task to run.</param>
        /// <returns>The TaskRun associated with the run.</returns>
        public TaskRun RunTask(Guid taskGuid)
        {
            return AsyncClient.RunTask(taskGuid).Result;
        }

        /// <summary>
        /// Runs a Task outside of a TaskList.
        /// </summary>
        /// <param name="task">The Task to run.</param>
        /// <returns>The TaskRun associated with the run.</returns>
        public TaskRun RunTask(TaskBase task)
        {
            return AsyncClient.RunTask(task).Result;
        }

        /// <summary>
        /// Updates the status of a TaskRun.
        /// </summary>
        /// <param name="taskRun">The TaskRun to update.</param>
        /// <returns>true if it was updated.</returns>
        public void UpdateTaskRun(TaskRun taskRun)
        {
            AsyncClient.UpdateTaskRun(taskRun).Wait();
        }

        /// <summary>
        /// Gets a TaskRun object.
        /// </summary>
        /// <param name="taskRunGuid">The GUID of the desired TaskRun</param>
        /// <returns>The TaskRun object.</returns>
        public TaskRun QueryTaskRun(Guid taskRunGuid)
        {
            return AsyncClient.QueryTaskRun(taskRunGuid).Result;
        }

        /// <summary>
        /// Gets all the data in a file on the Service's computer. It is recommended you use FactoryOrchestratorClient::GetFileFromDevice instead.
        /// </summary>
        /// <param name="sourceFilename">The path to the file to retrieve.</param>
        /// <param name="offset">If -1, read the whole file. Otherwise the starting byte to read the file from.</param>
        /// <param name="count">If offset is -1 this is ignored. Otherwise, the number of bytes to read from the file.</param>
        /// <param name="getFromContainer">If true, get the file from the container running on the connected device.</param>
        /// <returns>The bytes in the file.</returns>
        public byte[] GetFile(string sourceFilename, long offset = -1, int count = 0, bool getFromContainer = false)
        {
            return AsyncClient.GetFile(sourceFilename, offset , count , getFromContainer ).Result;
        }

        /// <summary>
        /// Saves data to a file to the Service's computer. It is recommended you use FactoryOrchestratorClient::SendFileToDevice instead.
        /// </summary>
        /// <param name="targetFilename">The name of the file you want created on the Service's computer.</param>
        /// <param name="fileData">The bytes you want saved to that file.</param>
        /// <param name="appendFile">If true, the file is appended to instead of overwritten.</param>
        /// <param name="sendToContainer">If true, send the file to the container running on the connected device.</param>
        /// <returns>true if the file was sucessfully created.</returns>
        public void SendFile(string targetFilename, byte[] fileData, bool appendFile = false, bool sendToContainer = false)
        {
            AsyncClient.SendFile(targetFilename, fileData, appendFile , sendToContainer ).Wait();
        }

        /// <summary>
        /// Permanently deletes a file or folder. If a folder, all contents are deleted.
        /// </summary>
        /// <param name="path">File or folder to delete</param>
        /// <param name="deleteInContainer">If true, delete the file from the container running on the connected device.</param>
        public void DeleteFileOrFolder(string path, bool deleteInContainer = false)
        {
            AsyncClient.DeleteFileOrFolder(path, deleteInContainer ).Wait();
        }

        /// <summary>
        /// Moves a file or folder to a new location.
        /// </summary>
        /// <param name="sourcePath">File or folder to move</param>
        /// <param name="destinationPath">Destination path</param>
        /// <param name="moveInContainer">If true, move the file from the container running on the connected device.</param>
        public void MoveFileOrFolder(string sourcePath, string destinationPath, bool moveInContainer = false)
        {
            AsyncClient.MoveFileOrFolder(sourcePath, destinationPath, moveInContainer ).Wait();
        }

        /// <summary>
        /// Returns a list of all directories in a given folder.
        /// </summary>
        /// <param name="path">The folder to search.</param>
        /// <param name="recursive">If true, search recursively.</param>
        /// <param name="inContainer">If true, look for directories in the container running on the connected device.</param>
        /// <returns></returns>
        public List<string> EnumerateDirectories(string path, bool recursive = false, bool inContainer = false)
        {
            return AsyncClient.EnumerateDirectories(path, recursive , inContainer ).Result;
        }

        /// <summary>
        /// Returns a list of all files in a given folder.
        /// </summary>
        /// <param name="path">The folder to search.</param>
        /// <param name="recursive">If true, search recursively.</param>
        /// <param name="inContainer">If true, look for files in the container running on the connected device.</param>
        /// <returns></returns>
        public List<string> EnumerateFiles(string path, bool recursive = false, bool inContainer = false)
        {
            return AsyncClient.EnumerateFiles(path, recursive , inContainer ).Result;
        }


    }
}
